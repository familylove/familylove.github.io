---
layout: post
title:  "JS -  Function "
date:   2016-11-16
excerpt: "js function"
tags: [js function]
comments: true
---

### Js question function

Question : 

    function foo(a, b, c){
  		return a+b+c;
	}

	function curry(fn){
		// do your code
		// return fn
	}

	var foo2 = curry(foo);

Hope :

    console.log(foo2(10)(20,30));  //60
	console.log(foo2(10,20)(30));  //60 too


### Thinking

看到这个问题觉得挺有意思，考察基本功理解能力，刚好有空就去写写看。

期待结果是执行两遍函数最后调用foo完成计算。

我的理解是foo2返回的必定是个函数 foo2()()才能够继续执行下去,可是参数如何传入一直是个问题。
fn.length 可以明确 fn 所需参数的个数，那么如果我能将入参获取到并且传入fn调用foo就结束了。
最后想到的解决方案是利用匿名函数传入参数，并且持有，如果入参不满足fn.length的入参需求，就继续返回匿名函数，直到满足条件为止。

整个解决方案如下：

    function foo(a, b, c){
  		return a+b+c;
	}

	function curry(fn){
	    return (function(){
	        if(arguments.length<fn.length){
	            var args = Array.prototype.slice.call(arguments);
	            return (function(){
	                for(var i=0;i<arguments.length;i++){
	                    args.push(arguments[i]);
	                }
	                if(args.length<fn.length){
	                    return arguments.callee;						
	                }else{
	                    return fn.apply(this,args);
	                }
	            });
	        }else{
	            return fn.apply(this,args);
	        }
	    });
	}
	var foo2 = curry(foo);

	console.log(foo2(10)(20)(30));      //60
	console.log(foo2(10)(20,30));       //60
	console.log(foo2(10,20)(30));       //60
	console.log(foo2(10,20)(30,40));    //60

	console.log(foo2(10)(20)(30)(40));  //error

这样就满足需求了，可是最后一种情况无法兼容，略感遗憾，没有万能的代码。
完成之后略有小得，记录下来，问了问提问者解决方案，期待比较一下。
